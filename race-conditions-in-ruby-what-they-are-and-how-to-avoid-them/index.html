<!DOCTYPE html> <html lang="en" class="h-full"> <head> <!-- Global site tag (gtag.js) - Google Analytics --> <script async src="https://www.googletagmanager.com/gtag/js?id=G-2LTH48DE8D"></script> <script> window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', 'G-2LTH48DE8D'); </script> <meta charset="utf-8"> <meta name=viewport content="width=device-width, initial-scale=1"> <meta name=author content="Risal Hidayat"> <!-- Begin Jekyll SEO tag v2.8.0 --> <title>Race conditions in Ruby what they are and how to avoid them | Risal Hidayat</title> <meta name="generator" content="Jekyll v4.2.2" /> <meta property="og:title" content="Race conditions in Ruby what they are and how to avoid them" /> <meta property="og:locale" content="en_US" /> <meta name="description" content="A race condition occurs when two or more threads can access shared data and they try to change it at the same time. As a result, the values of variables may be unpredictable and vary depending on the timings of context switches of the process." /> <meta property="og:description" content="A race condition occurs when two or more threads can access shared data and they try to change it at the same time. As a result, the values of variables may be unpredictable and vary depending on the timings of context switches of the process." /> <link rel="canonical" href="https://rslhdyt.dev/race-conditions-in-ruby-what-they-are-and-how-to-avoid-them/" /> <meta property="og:url" content="https://rslhdyt.dev/race-conditions-in-ruby-what-they-are-and-how-to-avoid-them/" /> <meta property="og:site_name" content="Risal Hidayat" /> <meta property="og:type" content="article" /> <meta property="article:published_time" content="2023-10-31T17:00:00+00:00" /> <meta name="twitter:card" content="summary" /> <meta property="twitter:title" content="Race conditions in Ruby what they are and how to avoid them" /> <meta name="twitter:site" content="@" /> <script type="application/ld+json"> {"@context":"https://schema.org","@type":"BlogPosting","dateModified":"2023-10-31T17:00:00+00:00","datePublished":"2023-10-31T17:00:00+00:00","description":"A race condition occurs when two or more threads can access shared data and they try to change it at the same time. As a result, the values of variables may be unpredictable and vary depending on the timings of context switches of the process.","headline":"Race conditions in Ruby what they are and how to avoid them","mainEntityOfPage":{"@type":"WebPage","@id":"https://rslhdyt.dev/race-conditions-in-ruby-what-they-are-and-how-to-avoid-them/"},"url":"https://rslhdyt.dev/race-conditions-in-ruby-what-they-are-and-how-to-avoid-them/"}</script> <!-- End Jekyll SEO tag --> <link rel="apple-touch-icon" sizes="180x180" href="https://rslhdyt.dev/assets/images/favicon/apple-touch-icon.png"> <link rel="icon" type="image/png" sizes="32x32" href="https://rslhdyt.dev/assets/images/favicon/favicon-32x32.png"> <link rel="icon" type="image/png" sizes="16x16" href="https://rslhdyt.dev/assets/images/favicon/favicon-16x16.png"> <link rel="manifest" href="https://rslhdyt.dev/site.webmanifest"> <link rel="canonical" href="https://rslhdyt.dev/race-conditions-in-ruby-what-they-are-and-how-to-avoid-them/"> <link rel="alternate" type="application/rss+xml" title="Risal Hidayat" href="https://rslhdyt.dev/feed.xml" /> <script src="https://kit.fontawesome.com/d9b09040a7.js" crossorigin="anonymous"></script> <!-- highlight.js --> <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/a11y-dark.min.css" integrity="sha512-Vj6gPCk8EZlqnoveEyuGyYaWZ1+jyjMPg8g4shwyyNlRQl6d3L9At02ZHQr5K6s5duZl/+YKMnM3/8pDhoUphg==" crossorigin="anonymous" referrerpolicy="no-referrer" /> <script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/11.4.0/highlight.min.js"></script> <script>hljs.highlightAll();</script> <link rel="stylesheet" href="/assets/css/main.css"> </head> <body class="bg-zinc-50 flex h-full"> <div class="max-w-[600px] flex flex-col mx-auto w-11/12"> <nav class=" mt-7 md:mt-10 mb-10"> <ul class="flex flex-row justify-center space-x-6 text-l text-gray-500"> <li> <a href="https://rslhdyt.dev/">Home</a> </li> <li> <a href="https://rslhdyt.dev/blog">Blog</a> </li> <li class="item hidden sm:block"> <a href="https://rslhdyt.dev/code_snippet">Code Snippet</a> </li> <li> <a href="https://rslhdyt.dev/projects">Projects</a> </li> <li> <a href="https://rslhdyt.dev/about">About</a> </li> </ul> </nav> <h1 class="text-3xl text-center tracking-tight font-bold mb-5">Race conditions in Ruby what they are and how to avoid them</h1> <span class="block text-center mb-5"> <time datetime="31-10-2023">Tuesday. October 31, 2023</time> - <span class="reading-time" title="Estimated read time"> 7 mins read </span> </span> <div class="flex flex-row space-x-1.5 justify-center mb-10"> <a class="bg-gray-200 px-2 rounded-sm font-thin" href="https://rslhdyt.dev/tags/rails">rails</a> <a class="bg-gray-200 px-2 rounded-sm font-thin" href="https://rslhdyt.dev/tags/race-condition">race-condition</a> <a class="bg-gray-200 px-2 rounded-sm font-thin" href="https://rslhdyt.dev/tags/tips">tips</a> <a class="bg-gray-200 px-2 rounded-sm font-thin" href="https://rslhdyt.dev/tags/database-locking">database-locking</a> </div> <div class="posts"> <p>A race condition occurs when two or more threads can access shared data and they try to change it at the same time. As a result, the values of variables may be unpredictable and vary depending on the timings of context switches of the process.</p> <p>To understand this better, imagine that we are In a situation where there are multiple people in a room discussing something, but only the person holding the microphone is allowed to speak at any given time, this is an example of a mutual exclusion or “mutex” condition. In this situation, the ability to speak is a shared resource that is restricted to only one person at a time. This ensures that only one person can speak at a time, and prevents multiple people from talking over each other.</p> <p><img src="/assets/images/posts/95310e45-b4c1-4a4f-a805-c7786b8cc1f6-DALLE_2022-12-06_22.28.19_-_a_microphone_surrounded_by_people_in_a_circle.png" alt="" /></p> <p><em>This image generated by AI</em></p> <p>In Ruby, you can use a mutex (mutual exclusion) to address race conditions. A mutex allows only one thread to access a shared resource at the same time, so other threads must wait until the mutex is released before they can access the resource.</p> <p>Here is an example of using a mutex to prevent a race condition in Ruby:</p> <div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">require</span> <span class="s1">'thread'</span>

<span class="c1"># Create a mutex</span>
<span class="n">mutex</span> <span class="o">=</span> <span class="no">Mutex</span><span class="p">.</span><span class="nf">new</span>

<span class="c1"># Define a shared variable</span>
<span class="n">counter</span> <span class="o">=</span> <span class="mi">0</span>

<span class="c1"># Define a function that increments the counter</span>
<span class="c1"># and acquires the mutex before doing so</span>
<span class="k">def</span> <span class="nf">increment_counter</span><span class="p">(</span><span class="n">mutex</span><span class="p">,</span> <span class="n">counter</span><span class="p">)</span>
  <span class="n">mutex</span><span class="p">.</span><span class="nf">synchronize</span> <span class="k">do</span>
    <span class="n">counter</span> <span class="o">+=</span> <span class="mi">1</span>
  <span class="k">end</span>
<span class="k">end</span>

<span class="c1"># Start two threads that increment the counter</span>
<span class="c1"># using the shared function</span>
<span class="n">threads</span> <span class="o">=</span> <span class="p">[]</span>
<span class="mi">2</span><span class="p">.</span><span class="nf">times</span> <span class="k">do</span>
  <span class="n">threads</span> <span class="o">&lt;&lt;</span> <span class="no">Thread</span><span class="p">.</span><span class="nf">new</span> <span class="k">do</span>
    <span class="mi">10</span><span class="p">.</span><span class="nf">times</span> <span class="k">do</span>
      <span class="n">increment_counter</span><span class="p">(</span><span class="n">mutex</span><span class="p">,</span> <span class="n">counter</span><span class="p">)</span>
    <span class="k">end</span>
  <span class="k">end</span>
<span class="k">end</span>

<span class="c1"># Wait for the threads to finish</span>
<span class="n">threads</span><span class="p">.</span><span class="nf">each</span><span class="p">(</span><span class="o">&amp;</span><span class="ss">:join</span><span class="p">)</span>

<span class="c1"># Print the final value of the counter</span>
<span class="c1"># (should be 20)</span>
<span class="nb">puts</span> <span class="n">counter</span>
</code></pre></div></div> <p>In the previous example, the <code class="language-plaintext highlighter-rouge">increment_counter</code> function acquires the mutex using the <code class="language-plaintext highlighter-rouge">synchronize</code> method before incrementing the <code class="language-plaintext highlighter-rouge">counter</code> variable. This ensure that only one thread can execute the code inside the <code class="language-plaintext highlighter-rouge">synchronize</code> block at the same time, preventing race conditions.</p> <p>To test this code with rspec, you can use the <code class="language-plaintext highlighter-rouge">thread</code> and <code class="language-plaintext highlighter-rouge">rspec-mocks</code> gem. Here is an example rspec test that checks that the <code class="language-plaintext highlighter-rouge">counter</code> variable has the expected value after both threads have finished executing:</p> <div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># require the thread and rspec-mocks gems</span>
<span class="nb">require</span> <span class="s1">'thread'</span>
<span class="nb">require</span> <span class="s1">'rspec/mocks'</span>

<span class="n">describe</span> <span class="s1">'race condition prevention'</span> <span class="k">do</span>
  <span class="n">it</span> <span class="s1">'prevents race conditions using a mutex'</span> <span class="k">do</span>
    <span class="c1"># Create a mutex</span>
    <span class="n">mutex</span> <span class="o">=</span> <span class="no">Mutex</span><span class="p">.</span><span class="nf">new</span>

    <span class="c1"># Define a shared variable</span>
    <span class="n">counter</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="c1"># Define a function that increments the counter</span>
    <span class="c1"># and acquires the mutex before doing so</span>
    <span class="k">def</span> <span class="nf">increment_counter</span><span class="p">(</span><span class="n">mutex</span><span class="p">,</span> <span class="n">counter</span><span class="p">)</span>
      <span class="n">mutex</span><span class="p">.</span><span class="nf">synchronize</span> <span class="k">do</span>
        <span class="n">counter</span> <span class="o">+=</span> <span class="mi">1</span>
      <span class="k">end</span>
    <span class="k">end</span>

    <span class="c1"># Start two threads that increment the counter</span>
    <span class="c1"># using the shared function</span>
    <span class="n">threads</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="mi">2</span><span class="p">.</span><span class="nf">times</span> <span class="k">do</span>
      <span class="n">threads</span> <span class="o">&lt;&lt;</span> <span class="no">Thread</span><span class="p">.</span><span class="nf">new</span> <span class="k">do</span>
        <span class="mi">10</span><span class="p">.</span><span class="nf">times</span> <span class="k">do</span>
          <span class="n">increment_counter</span><span class="p">(</span><span class="n">mutex</span><span class="p">,</span> <span class="n">counter</span><span class="p">)</span>
        <span class="k">end</span>
      <span class="k">end</span>
    <span class="k">end</span>

    <span class="c1"># Wait for the threads to finish</span>
    <span class="n">threads</span><span class="p">.</span><span class="nf">each</span><span class="p">(</span><span class="o">&amp;</span><span class="ss">:join</span><span class="p">)</span>

    <span class="c1"># Expect the final value of the counter to be 20</span>
    <span class="n">expect</span><span class="p">(</span><span class="n">counter</span><span class="p">).</span><span class="nf">to</span> <span class="n">eq</span><span class="p">(</span><span class="mi">20</span><span class="p">)</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre></div></div> <p>The RSpec test creates the mutex, shared variable, and <code class="language-plaintext highlighter-rouge">increment_counter</code> function in the same way as the previous example. It then starts two threads that increment the <code class="language-plaintext highlighter-rouge">counter</code> variable using the <code class="language-plaintext highlighter-rouge">increment_counter</code> function. Finally, it expect the final value of the <code class="language-plaintext highlighter-rouge">counter</code> variable to 20. If the code is correct and the mutex is used to prevent race conditions, the test will pass.</p> <h3 id="handling-race-condition-from-database-layer">Handling race condition from database layer</h3> <p>To prevent race conditions at the database level, you can use database locking to coordinate access to shared data between threads or processes. This involves acquiring a lock on the database record that you want to modify, updating the record, and then releasing the lock.</p> <p>Here is an example of using database locking to prevent race condition in Ruby on Rails application:</p> <div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">User</span> <span class="o">&lt;</span> <span class="no">ApplicationRecord</span>
  <span class="c1"># lock the database record</span>
  <span class="c1"># before updating the quota attribute</span>
  <span class="k">def</span> <span class="nf">purchase_quota</span><span class="p">(</span><span class="n">quota</span><span class="p">)</span>
    <span class="no">User</span><span class="p">.</span><span class="nf">transaction</span> <span class="k">do</span>
      <span class="n">lock!</span>
      <span class="nb">self</span><span class="p">.</span><span class="nf">quota_balance</span> <span class="o">=</span> <span class="n">quota</span>
      <span class="n">save!</span>
    <span class="k">end</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre></div></div> <p>The <code class="language-plaintext highlighter-rouge">purchase_quota</code> method uses the <code class="language-plaintext highlighter-rouge">transaction</code> method provided by Active Record to wrap the database operations in a transaction. This ensures that the database record for the <code class="language-plaintext highlighter-rouge">User</code> model is locked before the quota attribute is updated.</p> <p>The <code class="language-plaintext highlighter-rouge">lock!</code> method is used to lock the database record for the <code class="language-plaintext highlighter-rouge">User</code> model, and the <code class="language-plaintext highlighter-rouge">quota_balance</code> attribute is updated by adding the <code class="language-plaintext highlighter-rouge">quota</code> argument to it. Finally, the <code class="language-plaintext highlighter-rouge">save!</code> method is called to save the updated record to the database.</p> <p>Here is an example of how you could test for race conditions in the <code class="language-plaintext highlighter-rouge">**purchase_quota**</code> method:</p> <div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">require</span> <span class="s1">'rails_helper'</span>

<span class="no">RSpec</span><span class="p">.</span><span class="nf">describe</span> <span class="no">User</span><span class="p">,</span> <span class="ss">type: :model</span> <span class="k">do</span>
  <span class="n">describe</span> <span class="s1">'#purchase_quota'</span> <span class="k">do</span>
    <span class="n">it</span> <span class="s1">'prevents race conditions when transferring funds'</span> <span class="k">do</span>
      <span class="c1"># Create a user with a starting quota of 10</span>
      <span class="n">user</span> <span class="o">=</span> <span class="n">create</span><span class="p">(</span><span class="ss">:user</span><span class="p">,</span> <span class="ss">quota_balance: </span><span class="mi">10</span><span class="p">)</span>

      <span class="c1"># Start two threads that top up quota 10 to the user's account</span>
      <span class="n">threads</span> <span class="o">=</span> <span class="p">[]</span>
      <span class="mi">2</span><span class="p">.</span><span class="nf">times</span> <span class="k">do</span>
        <span class="n">threads</span> <span class="o">&lt;&lt;</span> <span class="no">Thread</span><span class="p">.</span><span class="nf">new</span> <span class="k">do</span>
          <span class="n">user</span><span class="p">.</span><span class="nf">purchase_quota</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span>
        <span class="k">end</span>
      <span class="k">end</span>

      <span class="c1"># Wait for the threads to finish</span>
      <span class="n">threads</span><span class="p">.</span><span class="nf">each</span><span class="p">(</span><span class="o">&amp;</span><span class="ss">:join</span><span class="p">)</span>

      <span class="c1"># Expect the user's quota balance to be 30</span>
      <span class="n">expect</span><span class="p">(</span><span class="n">user</span><span class="p">.</span><span class="nf">quota_balance</span><span class="p">).</span><span class="nf">to</span> <span class="n">eq</span><span class="p">(</span><span class="mi">30</span><span class="p">)</span>
    <span class="k">end</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre></div></div> <p>This test creates a new <code class="language-plaintext highlighter-rouge">**User**</code> record with a starting quota balance of 10, then starts two threads that each purchase 10 to the user’s table. After the threads have finished, it expects the user’s quota_balance to be 30.</p> <p>If the <code class="language-plaintext highlighter-rouge">purchase_quota</code> method is implemented correctly and uses database locking to prevent race conditions, this test will pass. However, if the method does not use locking and race conditions occur, the final value of the <code class="language-plaintext highlighter-rouge">**quota_balance**</code> attribute may not be predictable, and the test may fail.</p> <h2 id="conclusion">Conclusion</h2> <p>Race condition can occur in many different situations, but a common example is when multiple threads or processes try to update the same shared data at the same time. The previous example explains if we have an application that allows users to purchase the quota, and many processes can deduct the <code class="language-plaintext highlighter-rouge">quota_balance</code> at the same time, this can lead to a race condition.</p> <p>Without proper synchronization or locking, each user’s quota deduction may be processed independently, resulting in the quota balance of the target user being updated multiple times in an unpredictable manner. This can cause errors and inconsistencies in the data, and can lead to incorrect or unexpected results.</p> <p>By using database locking, you can prevent race conditions in situations like this by ensuring that only one thread or process can update the data at same time. This can help to ensure the consistency and integrity of the data in your database, and can prevent errors and inconsistencies that may be caused by race conditions.</p> <h3 id="source">Source:</h3> <ul> <li><a href="https://www.honeybadger.io/blog/avoid-race-condition-in-rails/">https://www.honeybadger.io/blog/avoid-race-condition-in-rails/</a></li> <li><a href="https://api.rubyonrails.org/classes/ActiveRecord/Locking/Pessimistic.html">https://api.rubyonrails.org/classes/ActiveRecord/Locking/Pessimistic.html</a></li> <li><a href="https://ruby-doc.org/core-2.5.0/Mutex.html">https://ruby-doc.org/core-2.5.0/Mutex.html</a></li> </ul> </div> <div class="grid grid-cols-2 text-sm"> <a class="prev" href="https://rslhdyt.dev/rails-rake-task-hooks/">&laquo; Rails - Rake Task Hooks</a> <a class="next" href="https://rslhdyt.dev/rails-authentication-login-with-magic-link/">Rails Authentication Login with magic link &raquo;</a> </div> <div class="related"> <h4 class="text-xl my-5">Related Posts</h4> <ul class="list-disc list-inside"> <li class="pl-8"> <a href="https://rslhdyt.dev/navigating-docker-debugging-challenges-overriding-entrypoint/">Navigating Docker Debugging Challenges: Overriding ENTRYPOINT </a> </li> <li class="pl-8"> <a href="https://rslhdyt.dev/webhookdump-database-design/">WebhookDump: Database Design </a> </li> <li class="pl-8"> <a href="https://rslhdyt.dev/streamline-your-sidekiq-cron-jobs-with-a-single-worker-class-for-rake-task-invocation/">Streamline Your Sidekiq Cron Jobs with a Single Worker Class for Rake Task Invocation </a> </li> <li class="pl-8"> <a href="https://rslhdyt.dev/setting-up-a-rails-project-for-webhookdump/">Setting Up a Rails Project for Webhookdump </a> </li> <li class="pl-8"> <a href="https://rslhdyt.dev/how-to-create-a-copy-to-clipboard-action-in-stimulus/">How to Create a Copy-to-Clipboard Action in Stimulus </a> </li> </ul> </div> <footer class="flex justify-center items-center border-solid border-0 border-t border-gray-200 p-10 mt-10"> Risal Hidayat © 2024 </footer> </div> </body> </html>
